-- ============================================
-- Nooble8 Database Schema
-- File: init_04_conversations.sql
-- Description: Conversations and messages tables
-- Version: 6.0
-- ============================================

-- ============================================
-- CONVERSATIONS TABLE
-- ============================================

CREATE TABLE public.conversations (
    id uuid PRIMARY KEY,  -- Deterministic UUID: uuid5(namespace, user:session:agent)
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    session_id uuid NOT NULL,  -- Visitor session (generated by backend)
    agent_id uuid NOT NULL REFERENCES public.agents(id) ON DELETE CASCADE,
    
    -- Visitor information (populated by backend)
    visitor_info jsonb DEFAULT '{
        "ip": null,
        "location": null,
        "device_type": null,
        "user_agent": null
    }'::jsonb,
    
    -- Status
    status conversation_status NOT NULL DEFAULT 'active',
    
    -- Timestamps
    started_at timestamptz NOT NULL DEFAULT now(),
    ended_at timestamptz,
    last_message_at timestamptz DEFAULT now(),
    
    -- Counters (updated by triggers)
    message_count integer DEFAULT 0,
    
    -- Additional data
    metadata jsonb DEFAULT '{}'::jsonb,
    
    created_at timestamptz DEFAULT now(),
    
    -- One conversation per user+session+agent combination
    CONSTRAINT conversations_unique_session UNIQUE(user_id, session_id, agent_id)
);

-- Indexes
CREATE INDEX idx_conversations_user ON public.conversations(user_id);
CREATE INDEX idx_conversations_agent ON public.conversations(agent_id);
CREATE INDEX idx_conversations_session ON public.conversations(session_id);
CREATE INDEX idx_conversations_status ON public.conversations(status);
CREATE INDEX idx_conversations_active ON public.conversations(status) WHERE status = 'active';
CREATE INDEX idx_conversations_started ON public.conversations(started_at);
CREATE INDEX idx_conversations_last_message ON public.conversations(last_message_at);

-- ============================================
-- MESSAGES TABLE
-- ============================================

CREATE TABLE public.messages (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    conversation_id uuid NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
    role message_role NOT NULL,
    content text NOT NULL,
    
    -- Token tracking for billing
    tokens_input integer DEFAULT 0,
    tokens_output integer DEFAULT 0,
    
    -- Model info
    model text,
    
    -- Performance metrics
    latency_ms integer,
    
    -- Additional data
    metadata jsonb DEFAULT '{}'::jsonb,
    
    created_at timestamptz DEFAULT now()
);

-- Indexes
CREATE INDEX idx_messages_conversation ON public.messages(conversation_id);
CREATE INDEX idx_messages_created ON public.messages(created_at);
CREATE INDEX idx_messages_role ON public.messages(role);
CREATE INDEX idx_messages_conversation_created ON public.messages(conversation_id, created_at);

-- ============================================
-- TRIGGERS
-- ============================================

-- Function: Update conversation message count and last_message_at
CREATE OR REPLACE FUNCTION update_conversation_on_message()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE public.conversations 
    SET 
        message_count = message_count + 1,
        last_message_at = NEW.created_at
    WHERE id = NEW.conversation_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger: Update conversation stats on new message
CREATE TRIGGER trigger_update_conversation_on_message
    AFTER INSERT ON public.messages
    FOR EACH ROW EXECUTE FUNCTION update_conversation_on_message();

-- ============================================
-- CONVERSATIONS RLS POLICIES
-- ============================================

ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;

-- Users can view conversations for their agents
CREATE POLICY "Users can view their agents conversations"
    ON public.conversations
    FOR SELECT
    TO authenticated
    USING (
        user_id = auth.uid() OR
        agent_id IN (SELECT id FROM agents WHERE user_id = auth.uid())
    );

-- Anyone can create conversations with public agents (for chat widget)
CREATE POLICY "Anyone can create conversations with public agents"
    ON public.conversations
    FOR INSERT
    WITH CHECK (
        agent_id IN (SELECT id FROM agents WHERE is_public = true AND is_active = true)
    );

-- Users can update their own conversations (e.g., close them)
CREATE POLICY "Users can update their conversations"
    ON public.conversations
    FOR UPDATE
    TO authenticated
    USING (
        user_id = auth.uid() OR
        agent_id IN (SELECT id FROM agents WHERE user_id = auth.uid())
    );

-- Service role has full access
CREATE POLICY "Service role has full access to conversations"
    ON public.conversations
    FOR ALL
    TO service_role
    USING (true)
    WITH CHECK (true);

-- ============================================
-- MESSAGES RLS POLICIES
-- ============================================

ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Users can view messages in their conversations
CREATE POLICY "Users can view messages in their conversations"
    ON public.messages
    FOR SELECT
    TO authenticated
    USING (
        conversation_id IN (
            SELECT id FROM conversations 
            WHERE user_id = auth.uid() 
            OR agent_id IN (SELECT id FROM agents WHERE user_id = auth.uid())
        )
    );

-- Anyone can view messages in public conversations
CREATE POLICY "Anyone can view messages in public conversations"
    ON public.messages
    FOR SELECT
    USING (
        conversation_id IN (
            SELECT c.id FROM conversations c
            JOIN agents a ON c.agent_id = a.id
            WHERE a.is_public = true
        )
    );

-- Anyone can create messages in active conversations
CREATE POLICY "Anyone can create messages in active conversations"
    ON public.messages
    FOR INSERT
    WITH CHECK (
        conversation_id IN (
            SELECT id FROM conversations WHERE status = 'active'
        )
    );

-- Service role has full access
CREATE POLICY "Service role has full access to messages"
    ON public.messages
    FOR ALL
    TO service_role
    USING (true)
    WITH CHECK (true);

-- ============================================
-- HELPER FUNCTIONS
-- ============================================

-- Function: Generate deterministic conversation ID
CREATE OR REPLACE FUNCTION generate_conversation_id(
    p_user_id uuid,
    p_session_id uuid,
    p_agent_id uuid
) RETURNS uuid AS $$
BEGIN
    -- Use a fixed namespace for Nooble8 conversations
    RETURN uuid_generate_v5(
        'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'::uuid,
        p_user_id::text || ':' || p_session_id::text || ':' || p_agent_id::text
    );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Function: Close conversation
CREATE OR REPLACE FUNCTION close_conversation(p_conversation_id uuid)
RETURNS void AS $$
BEGIN
    UPDATE conversations
    SET 
        status = 'closed',
        ended_at = now()
    WHERE id = p_conversation_id AND status = 'active';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Archive old conversations (called by scheduled job)
CREATE OR REPLACE FUNCTION archive_old_conversations(p_months integer DEFAULT 12)
RETURNS integer AS $$
DECLARE
    v_count integer;
BEGIN
    WITH archived AS (
        UPDATE conversations
        SET status = 'archived'
        WHERE status IN ('active', 'closed')
        AND last_message_at < now() - (p_months || ' months')::interval
        RETURNING id
    )
    SELECT COUNT(*) INTO v_count FROM archived;
    
    RETURN v_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Delete archived conversations older than specified months
CREATE OR REPLACE FUNCTION delete_old_conversations(p_months integer DEFAULT 12)
RETURNS integer AS $$
DECLARE
    v_count integer;
BEGIN
    WITH deleted AS (
        DELETE FROM conversations
        WHERE status = 'archived'
        AND last_message_at < now() - (p_months || ' months')::interval
        RETURNING id
    )
    SELECT COUNT(*) INTO v_count FROM deleted;
    
    RETURN v_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- VIEWS
-- ============================================

-- View: Conversation summary
CREATE OR REPLACE VIEW public.conversation_summary AS
SELECT 
    c.id,
    c.user_id,
    c.session_id,
    c.agent_id,
    a.name as agent_name,
    c.visitor_info,
    c.status,
    c.started_at,
    c.ended_at,
    c.message_count,
    c.last_message_at,
    CASE 
        WHEN c.ended_at IS NOT NULL THEN c.ended_at - c.started_at
        ELSE now() - c.started_at
    END as duration,
    (SELECT COUNT(*) FROM messages m WHERE m.conversation_id = c.id AND m.role = 'user') as user_messages,
    (SELECT COUNT(*) FROM messages m WHERE m.conversation_id = c.id AND m.role = 'assistant') as assistant_messages,
    (SELECT SUM(tokens_input) FROM messages m WHERE m.conversation_id = c.id) as total_tokens_input,
    (SELECT SUM(tokens_output) FROM messages m WHERE m.conversation_id = c.id) as total_tokens_output
FROM public.conversations c
LEFT JOIN public.agents a ON c.agent_id = a.id;

-- ============================================
-- GRANTS
-- ============================================

GRANT SELECT ON public.conversations TO anon;
GRANT SELECT, INSERT, UPDATE ON public.conversations TO authenticated;
GRANT ALL ON public.conversations TO service_role;

GRANT SELECT, INSERT ON public.messages TO anon;
GRANT SELECT, INSERT ON public.messages TO authenticated;
GRANT ALL ON public.messages TO service_role;

GRANT SELECT ON public.conversation_summary TO authenticated;
GRANT SELECT ON public.conversation_summary TO service_role;

GRANT EXECUTE ON FUNCTION generate_conversation_id TO anon;
GRANT EXECUTE ON FUNCTION generate_conversation_id TO authenticated;
GRANT EXECUTE ON FUNCTION generate_conversation_id TO service_role;

GRANT EXECUTE ON FUNCTION close_conversation TO authenticated;
GRANT EXECUTE ON FUNCTION close_conversation TO service_role;

GRANT EXECUTE ON FUNCTION archive_old_conversations TO service_role;
GRANT EXECUTE ON FUNCTION delete_old_conversations TO service_role;

-- ============================================
-- COMMENTS
-- ============================================

COMMENT ON TABLE public.conversations IS 'Chat conversations between visitors and agents';
COMMENT ON TABLE public.messages IS 'Individual messages within conversations';

COMMENT ON COLUMN public.conversations.id IS 'Deterministic UUID based on user_id:session_id:agent_id';
COMMENT ON COLUMN public.conversations.user_id IS 'Owner of the agent (profile owner)';
COMMENT ON COLUMN public.conversations.session_id IS 'Visitor session identifier (generated by backend)';
COMMENT ON COLUMN public.conversations.visitor_info IS 'Information about the visitor (IP, device, etc.)';

COMMENT ON COLUMN public.messages.tokens_input IS 'Input tokens consumed by this message';
COMMENT ON COLUMN public.messages.tokens_output IS 'Output tokens generated for this message';
COMMENT ON COLUMN public.messages.latency_ms IS 'Response time in milliseconds';
